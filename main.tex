\documentclass[11pt]{style/preprint}
\usepackage{style/comment}
\usepackage{style/mhenvs}
\usepackage{style/mhsymb}
\usepackage{style/trees}

\usepackage[full]{textcomp}
\usepackage[osf]{newtxtext}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{mhequ}
\usepackage{booktabs}
\usepackage{tikz}
\usepackage{mathrsfs}
\usepackage{longtable}
\usepackage{microtype}
\usepackage{wasysym}
\usepackage{centernot}
\usepackage{enumitem}
\usepackage[dvipsnames]{xcolor}
\usepackage{hyperref}
\hypersetup{
  pdftitle={},
  pdfauthor={Kexing Ying},
  colorlinks=true,
  linkcolor=Maroon,
  filecolor=Maroon,
  citecolor=Maroon,
  urlcolor=Maroon,
  pdfcreator={LaTeX via pandoc}}
\usepackage{crossreftools}
\usepackage{physics}
\usepackage[notref,notcite]{showkeys}

\input{style/prelude.tex}

\begin{document}

\title{Branched Rough Path Notes\\
  \large Based on \href{arxiv.org/abs/1210.6294}{arxiv.org/abs/1210.6294}}
\author{}
\institute{}
\maketitle

% \begin{equ}
% \fT = \{\<1>,\<2>,\<2>_x,\<20>,\<3>,\<30>, \<22>, \<31>,\<32>\}\;,
% \end{equ}

\section{Trees}

% Whilst for level 2 rough paths (i.e. \(\alpha \in \left(\frac{1}{3}, \frac{1}{2}\right]\)), we can 
% get away with writing out the the algebraic and analytic conditions explicitly, this quickly becomes 
% unbearable for higher level rough paths. Instead, by using the language of trees, it turns out 
% that these conditions can be written neatly into a single equation.

For higher order rough paths, it is useful to introduce tree notations to keep track of the 
algebraic and analytic conditions for the extra terms arising from the Taylor expansion.

\begin{definition}
  Denote \(\CT\) for the set of all rooted and labeled trees and \(\CF\) for the set of the associated 
  forests, i.e. \(\CF\) is the free abelian monoid generated buy \(\CT\) and \(f \in \CF\) is a finite 
  collection of rooted labeled trees (where we allow multiple copies of the same tree).
\end{definition}

Some examples of rooted and labeled trees are 
\[\<X>, \<1>, \<2>, \<10>, \<3>, \<20>, \<100>, \cdots\]
We write \(f = \prod_{i \in I} h_i \in \CF\) as a commutative product where \(h_i \in \CT\) and \(I\) 
is a finite index set. We allow \(\CT\) to contain the empty tree and we denote it by \(\mathbf{1}\) 
since it is the multiplicative identity in \(\CF\). We introduce the rooting operation \([-]_a : \CF \to \CT\) where 
for \(f \in \CF\), we define \([f]_a\) for the tree obtained by joining all the trees in \(f\) to the
root \(a\), e.g. 
\[[\mathbf{1}]_a = \<X> \text{ and } [\;\<X> \<1cb>]_d = \<X10>.\]
For \(h \in \CT\), denote \(f_h\) for the number of copies of \(h\) in \(f\). Thus, we can write 
\(f = \prod_{h \in \CT} h^{f_h}\)
where \(f_h\) is zero for all but finitely many terms. Namely, \(h \in f\) if and only if 
\(f_h \neq 0\). For \(h \in \CT\), the order of \(h\): \(|h|\) is simply the number of vertices of 
\(h\) and for \(f \in \CF\), \(|f| = \sum_{h \in \CT} f_h |h|\). We also write \(\#f = \sum_{h \in \CT} f_h\).

We denote \(\langle \CF \rangle\) for the free vector space generated by \(\CF\) so \(\langle \CF\rangle\) 
is a unital commutative algebra with identity \(\mathbf{1}\). We define the inner product of \(\langle \CF \rangle\)
by setting 
\[\langle f, f'\rangle = \mathbf{1}_{f = f'}\]
for all \(f, f' \in \CF\) and extending linearly. 

We define the coproduct \(\Delta : \langle \CF \rangle \to \langle \CF \rangle \otimes \langle \CF \rangle\) 
by first defining \(\Delta\) on \(\CF\) inductively and then extending linearly. In particular, we set
\begin{itemize}
  \item \(\Delta \mathbf{1} = \mathbf{1} \otimes \mathbf{1}\).
  \item For \(f \in \CF\), \(\Delta f = \prod_{h \in \CT} (\Delta h)^{f_h}\).
  \item For \(f \in \CF\), \(\Delta [f]_a = [f]_a \otimes \mathbf{1} + (\text{id} \otimes [-]_a) \Delta f\).
\end{itemize} 
Here are some examples:
\begin{itemize}
  \item \(\Delta\; \<X> = \<X> \otimes \mathbf{1} + \mathbf{1} \otimes \<X>\).
  \item \(\Delta \<1> = \<1> \otimes \mathbf{1} + \<X> \otimes \<Xb> + \mathbf{1} \otimes \<1>\).
  \item \(\Delta \<2> = \<2> \otimes \mathbf{1} + \<X> \<Xb> \otimes \<Xc> + \<Xc> \otimes \<1> 
    + \<Xb> \otimes \<1ac> + \mathbf{1} \otimes \<2>\).
\end{itemize}

\section{Hopf Algebra}

The algebra \(\langle \CF\rangle\) equipped with the coproduct \(\Delta\) forms what is known as a 
Hopf algebra (in particular, it is the Connes-Kreimer Hopf algebra). We in this section provide a 
informal introduction to Hopf algebras.

Before we proceed with defining Hopf algebra, we first need to introduce \textit{bialgebras}.
Suppose we have an algebra \(\CH^*\) acting on another algebra \(\CH^*\) via the action 
\[\langle \cdot, \cdot \rangle : \CH^* \otimes \CH \to \mathbb{R}.\]
Informally speaking, a bialgebra is then \(\CH\) equipped with a \textit{coproduct} \(\Delta : \CH \to \CH \otimes \CH\) 
which encodes this pairing and in particular, preserves the product structure of \(\CH^*\). More precisely,
\(\Delta\) is dual to the product operator \(\nabla^*\) of \(\CH^*\) in the sense that 
\[\langle \nabla^*(f \otimes g), h\rangle = \langle f \otimes g, \Delta h\rangle\]
where \(\nabla^* : \CH^* \otimes \CH^* \to \CH^*\) is such that \(\nabla^*(x, y) = xy\). Thus, in some 
sense, once we have the coproduct \(\Delta\), we can forget about \(\CH^*\) and work solely with \(\CH\).

A bialgebra \((\CH, \Delta)\) is \textit{graded} if it has the decomposition 
\[\CH = \bigoplus_{n \in \mathbb{N}} \CH_{(n)}\]
where \(H_{(n)}\) are vector spaces such that for all \(n, m \in \mathbb{N}\),
\[\CH_{(n)} \cdot \CH_{(m)} \subseteq \CH_{(n + m)}, \text{ and } 
  \Delta \CH_{(n)} \subseteq \bigoplus_{p + q = n} \CH_{(p)} \otimes \CH_{(q)}.\]
Denoting \(\CF_{(n)} = \{f \in \CF : |f| = n\}\), taking \(\CH_{(n)} = \langle \CF_{(n)}\rangle\), 
we observe that \(\CF\) is a graded bialgebra. 

While the coproduct preserves the product structure of \(\CH^*\), we would also like a map which 
preserves the units (invertible elements) of \(\CH^*\). This is achieved with the \textit{antipole} 
map \(S : \CH \to \CH\) which is required to satisfy
\begin{equation}\label{eq:antipole}
  \nabla (S \otimes \text{id}) \Delta h = \nabla (\text{id} \otimes S) \Delta h = \langle \mathbf{1}, h\rangle \mathbf{1}
\end{equation}
for all \(h \in \CH\), where \(\nabla\) is the product operator of \(\CH\) and 
\[\langle\mathbf{1}, h\rangle = 
\begin{cases}
  1 & \text{if } h = \mathbf{1},\\
  0 & \text{otherwise}.
\end{cases}\]
This condition is motivated by the fact that, if \(S\) is such that for any unit \(f \in \CH^*\), 
\(S^* f = f^{-1}\) where \(S^* : \CH^* \to \CH^*\) is the dual of \(S\), then
\[\langle f \otimes f, (S \otimes \text{id})\Delta h\rangle 
  = \langle \nabla^* (S^* f \otimes f), h\rangle = \langle S^* f \cdot f, h\rangle = \langle \mathbf{1}, h\rangle.\]
On the other hand, 
\[\langle f \otimes f, \langle \mathbf{1}, h\rangle \mathbf{1} \otimes \mathbf{1}\rangle = \langle \mathbf{1}, h\rangle.\]
Hence, in order for \(S\) to preserve the unit structure of \(\CH^*\), it is necessary to require
\(\nabla (S \otimes \text{id})\Delta h = \nabla \langle \mathbf{1}, h\rangle \mathbf{1} \otimes \mathbf{1} 
= \langle \mathbf{1}, h\rangle\). 

With the antipole motivated, a Hopf algebra is then simply a bialgebra equipped with an antipole.

\begin{proposition}
  A graded bialgebra satisfying \(\CH_{(0)} = \mathbb{R}\) is automatically a Hopf algebra.
\end{proposition}

Thus, as \(\langle \CF_{(0)}\rangle = \mathbb{R}\), it follows \(\langle \CF\rangle\) is a Hopf algebra.
The antipole \(S\) of \(\langle \CF\rangle\) can be computed explicitly by using the identity~\eqref{eq:antipole}. 
We give some examples:
\begin{itemize}
  \item \(S \mathbf{1} = \mathbf{1}\).
  \item \(0 = \nabla (S \otimes \text{id}) \Delta \<X> = S \<X> + \<X>\). Thus, \(S \<X> = -\<X>\).
  \item \(0 = \nabla (S \otimes \text{id}) \Delta \<1> = S \<1> + (S \<X>) \<Xb> + \<1>\). 
    Thus, \(S \<1> = -\<1> + \<X> \<Xb>\).
  \item \(0 = \nabla (S \otimes \text{id}) \Delta \<2> = S \<2> + (S \<X> \<Xb>) \<Xc> + (S \<Xc>) \<1> + (S \<Xb>) \<1ac> + \<2>\).
    Thus, \(S \<2> = -\<2> + \<Xc> \<1> + \<Xb> \<1ac> - \<X> \<Xb> \<Xc>\).
\end{itemize}


\end{document}
